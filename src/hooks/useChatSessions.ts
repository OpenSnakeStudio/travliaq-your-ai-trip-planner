import { useState, useCallback, useEffect, useRef } from "react";
import { supabase } from "@/integrations/supabase/client";
import { useAuth } from "@/contexts/AuthContext";

export interface StoredMessage {
  id: string;
  role: "assistant" | "user" | "system";
  text: string;
  hasSearchButton?: boolean;
  isHidden?: boolean;
  isStreaming?: boolean;
  isTyping?: boolean;
  // Widget persistence for chat history stability
  widget?: string;
  widgetData?: unknown;
  widgetConfirmed?: boolean;
  widgetSelectedValue?: unknown;
  widgetDisplayLabel?: string;
  isAutoGenerated?: boolean;
}

export interface ChatSession {
  id: string;
  title: string;
  createdAt: number;
  updatedAt: number;
  preview: string;
}

const SESSIONS_INDEX_KEY = "travliaq_chat_sessions_index";
const SESSION_PREFIX = "travliaq_chat_session_";
const SYNC_DEBOUNCE_MS = 3000;

const generateId = () => crypto.randomUUID();

// Default translations (French fallback - will be overridden by i18n in components)
const DEFAULT_TRANSLATIONS = {
  newConversation: "Nouvelle conversation",
  startConversation: "DÃ©marrez la conversation...",
  welcomeMessage: "Bonjour ! Je suis votre assistant de voyage. Dites-moi oÃ¹ vous souhaitez aller et je vous aiderai Ã  planifier votre voyage.",
};

const getDefaultWelcomeMessage = (translations = DEFAULT_TRANSLATIONS): StoredMessage => ({
  id: "welcome",
  role: "assistant",
  text: translations.welcomeMessage,
});

// Emojis for trip titles based on destination keywords
const TRIP_EMOJIS: Record<string, string> = {
  plage: "ðŸ–ï¸", beach: "ðŸ–ï¸", mer: "ðŸŒŠ", ocean: "ðŸŒŠ",
  montagne: "â›°ï¸", mountain: "â›°ï¸", ski: "â›·ï¸", neige: "â„ï¸",
  ville: "ðŸ™ï¸", city: "ðŸ™ï¸", urban: "ðŸŒ†",
  nature: "ðŸŒ¿", foret: "ðŸŒ²", forest: "ðŸŒ²",
  desert: "ðŸœï¸", safari: "ðŸ¦",
  asie: "ðŸ¯", asia: "ðŸ¯", japon: "ðŸ—¼", japan: "ðŸ—¼", tokyo: "ðŸ—¼", chine: "ðŸ‰", china: "ðŸ‰",
  europe: "ðŸ°", paris: "ðŸ—¼", france: "ðŸ‡«ðŸ‡·", italie: "ðŸ‡®ðŸ‡¹", italy: "ðŸ", rome: "ðŸ›ï¸", espagne: "ðŸ‡ªðŸ‡¸", spain: "ðŸ’ƒ",
  amerique: "ðŸ—½", america: "ðŸ—½", usa: "ðŸ‡ºðŸ‡¸", newyork: "ðŸ—½", miami: "ðŸŒ´", losangeles: "ðŸŽ¬",
  afrique: "ðŸŒ", africa: "ðŸŒ", maroc: "ðŸ•Œ", morocco: "ðŸ•Œ", egypte: "ðŸº", egypt: "ðŸº",
  ile: "ðŸï¸", island: "ðŸï¸", maldives: "ðŸï¸", bali: "ðŸŒº", hawaii: "ðŸŒº",
  romantique: "ðŸ’•", romantic: "ðŸ’•", honeymoon: "ðŸ’’",
  aventure: "ðŸ§—", adventure: "ðŸ§—", randonnee: "ðŸ¥¾", hiking: "ðŸ¥¾",
  famille: "ðŸ‘¨â€ðŸ‘©â€ðŸ‘§â€ðŸ‘¦", family: "ðŸ‘¨â€ðŸ‘©â€ðŸ‘§â€ðŸ‘¦", enfants: "ðŸ‘¶", kids: "ðŸ‘¶",
  solo: "ðŸŽ’", backpack: "ðŸŽ’",
  luxe: "âœ¨", luxury: "âœ¨", spa: "ðŸ’†",
  gastronomie: "ðŸ½ï¸", food: "ðŸœ", cuisine: "ðŸ‘¨â€ðŸ³",
  weekend: "ðŸŒŸ", vacances: "ðŸŒ´", holidays: "ðŸŒ´", voyage: "âœˆï¸", trip: "âœˆï¸",
};

const getEmojiForText = (text: string): string => {
  const lowerText = text.toLowerCase();
  for (const [keyword, emoji] of Object.entries(TRIP_EMOJIS)) {
    if (lowerText.includes(keyword)) {
      return emoji;
    }
  }
  // Default travel emoji
  return "âœˆï¸";
};

const generateTitle = (messages: StoredMessage[], translations = DEFAULT_TRANSLATIONS): string => {
  const firstUserMessage = messages.find((m) => m.role === "user");
  if (firstUserMessage) {
    const text = firstUserMessage.text.slice(0, 35);
    const emoji = getEmojiForText(firstUserMessage.text);
    const truncatedText = text.length < firstUserMessage.text.length ? text + "..." : text;
    return `${emoji} ${truncatedText}`;
  }
  return `âœˆï¸ ${translations.newConversation}`;
};

const generatePreview = (messages: StoredMessage[], translations = DEFAULT_TRANSLATIONS): string => {
  const lastMessage = [...messages].reverse().find((m) => !m.isHidden && m.text);
  if (lastMessage) {
    const text = lastMessage.text.slice(0, 50);
    return text.length < lastMessage.text.length ? text + "..." : text;
  }
  return translations.startConversation;
};

export interface ChatTranslations {
  newConversation: string;
  startConversation: string;
  welcomeMessage: string;
}

interface UseChatSessionsOptions {
  getFlightMemory?: () => Record<string, unknown>;
  getAccommodationMemory?: () => Record<string, unknown>;
  getTravelMemory?: () => Record<string, unknown>;
  translations?: ChatTranslations;
}

export const useChatSessions = (options: UseChatSessionsOptions = {}) => {
  const { getFlightMemory, getAccommodationMemory, getTravelMemory, translations = DEFAULT_TRANSLATIONS } = options;
  const { user } = useAuth();
  
  const [sessions, setSessions] = useState<ChatSession[]>([]);
  const [activeSessionId, setActiveSessionId] = useState<string>("");
  const [messages, setMessages] = useState<StoredMessage[]>([]);
  
  const syncTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);
  const isSyncingRef = useRef(false);
  const lastSyncRef = useRef<number>(0);

  // Sync session to database
  const syncToDatabase = useCallback(
    async (sessionId: string, sessionMessages: StoredMessage[], session: ChatSession | undefined) => {
      if (!user || !sessionId) return;
      if (isSyncingRef.current) return;

      const now = Date.now();
      if (now - lastSyncRef.current < SYNC_DEBOUNCE_MS) return;

      isSyncingRef.current = true;
      lastSyncRef.current = now;

      try {
        const payload = {
          chatSessionId: sessionId,
          flightMemory: getFlightMemory?.() || {},
          accommodationMemory: getAccommodationMemory?.() || {},
          travelMemory: getTravelMemory?.() || {},
          chatMessages: sessionMessages,
          title: session?.title || generateTitle(sessionMessages),
          preview: session?.preview || generatePreview(sessionMessages),
        };

        console.log("[ChatSessions] Syncing to database:", sessionId);

        const { error } = await supabase.functions.invoke("sync-planner-session", {
          body: payload,
        });

        if (error) {
          console.error("[ChatSessions] Sync error:", error);
        } else {
          console.log("[ChatSessions] Sync successful");
        }
      } catch (error) {
        console.error("[ChatSessions] Sync failed:", error);
      } finally {
        isSyncingRef.current = false;
      }
    },
    [user, getFlightMemory, getAccommodationMemory, getTravelMemory]
  );

  // Schedule debounced sync
  const scheduleSyncDebounced = useCallback(
    (sessionId: string, sessionMessages: StoredMessage[], session: ChatSession | undefined) => {
      if (syncTimeoutRef.current) {
        clearTimeout(syncTimeoutRef.current);
      }
      syncTimeoutRef.current = setTimeout(() => {
        syncToDatabase(sessionId, sessionMessages, session);
      }, SYNC_DEBOUNCE_MS);
    },
    [syncToDatabase]
  );

  // Delete session from database
  const deleteFromDatabase = useCallback(
    async (sessionId: string) => {
      if (!user) return;

      try {
        console.log("[ChatSessions] Deleting from database:", sessionId);

        // Use DELETE method via query params
        const { error } = await supabase.functions.invoke(
          `sync-planner-session?sessionId=${sessionId}`,
          { method: "DELETE" }
        );

        if (error) {
          console.error("[ChatSessions] Delete error:", error);
        }
      } catch (error) {
        console.error("[ChatSessions] Delete failed:", error);
      }
    },
    [user]
  );

  // Load sessions index on mount
  useEffect(() => {
    try {
      const indexRaw = localStorage.getItem(SESSIONS_INDEX_KEY);
      let loadedSessions: ChatSession[] = [];
      
      if (indexRaw) {
        loadedSessions = JSON.parse(indexRaw);
      }

      // If no sessions exist, create the first one
      if (loadedSessions.length === 0) {
        const newSession: ChatSession = {
          id: generateId(),
          title: translations.newConversation,
          createdAt: Date.now(),
          updatedAt: Date.now(),
          preview: translations.startConversation,
        };
        loadedSessions = [newSession];
        localStorage.setItem(SESSIONS_INDEX_KEY, JSON.stringify(loadedSessions));
        localStorage.setItem(
          SESSION_PREFIX + newSession.id,
          JSON.stringify([getDefaultWelcomeMessage(translations)])
        );
      }

      setSessions(loadedSessions);

      // Load the most recent session
      const mostRecent = loadedSessions.sort((a, b) => b.updatedAt - a.updatedAt)[0];
      setActiveSessionId(mostRecent.id);
      
      // Load messages for that session
      const messagesRaw = localStorage.getItem(SESSION_PREFIX + mostRecent.id);
      if (messagesRaw) {
        const parsed = JSON.parse(messagesRaw);
        setMessages(Array.isArray(parsed) ? parsed : [getDefaultWelcomeMessage(translations)]);
      } else {
        setMessages([getDefaultWelcomeMessage(translations)]);
      }
    } catch (e) {
      console.error("Error loading chat sessions:", e);
      // Create a fresh session on error
      const newSession: ChatSession = {
        id: generateId(),
        title: translations.newConversation,
        createdAt: Date.now(),
        updatedAt: Date.now(),
        preview: translations.startConversation,
      };
      setSessions([newSession]);
      setActiveSessionId(newSession.id);
      setMessages([getDefaultWelcomeMessage(translations)]);
    }
  }, []);

  // Sync on visibility change (when user leaves tab)
  // Use refs to avoid re-creating this effect on every message change
  const messagesForSyncRef = useRef<StoredMessage[]>([]);
  const sessionsForSyncRef = useRef<ChatSession[]>([]);
  
  useEffect(() => {
    messagesForSyncRef.current = messages;
  }, [messages]);
  
  useEffect(() => {
    sessionsForSyncRef.current = sessions;
  }, [sessions]);

  useEffect(() => {
    const handleVisibilityChange = () => {
      if (document.visibilityState === "hidden" && user && activeSessionId) {
        const currentSession = sessionsForSyncRef.current.find(s => s.id === activeSessionId);
        syncToDatabase(activeSessionId, messagesForSyncRef.current, currentSession);
      }
    };

    document.addEventListener("visibilitychange", handleVisibilityChange);
    return () => {
      document.removeEventListener("visibilitychange", handleVisibilityChange);
    };
  }, [syncToDatabase, user, activeSessionId]);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      if (syncTimeoutRef.current) {
        clearTimeout(syncTimeoutRef.current);
      }
    };
  }, []);

  // Refs to prevent infinite loops
  const isUpdatingRef = useRef(false);
  const saveTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);
  const sessionsRef = useRef<ChatSession[]>([]);
  const messagesRef = useRef<StoredMessage[]>([]);

  // Keep refs in sync
  useEffect(() => {
    sessionsRef.current = sessions;
  }, [sessions]);

  useEffect(() => {
    messagesRef.current = messages;
  }, [messages]);

  // Save messages to localStorage only (no state updates here)
  const saveMessagesToStorage = useCallback(
    (newMessages: StoredMessage[], sessionId: string) => {
      if (!sessionId) return;

      try {
        // Save messages
        localStorage.setItem(SESSION_PREFIX + sessionId, JSON.stringify(newMessages));

        // Update session metadata in localStorage
        const currentSessions = sessionsRef.current;
        const updated = currentSessions.map((s) =>
          s.id === sessionId
            ? {
                ...s,
                title: generateTitle(newMessages),
                preview: generatePreview(newMessages),
                updatedAt: Date.now(),
              }
            : s
        );
        localStorage.setItem(SESSIONS_INDEX_KEY, JSON.stringify(updated));

        // Update sessions state without causing re-render loops
        if (!isUpdatingRef.current) {
          isUpdatingRef.current = true;
          setSessions(updated);
          sessionsRef.current = updated;
          isUpdatingRef.current = false;
        }

        // Schedule database sync
        if (user) {
          const currentSession = updated.find((s) => s.id === sessionId);
          scheduleSyncDebounced(sessionId, newMessages, currentSession);
        }
      } catch (e) {
        console.error("Error saving messages:", e);
      }
    },
    [user, scheduleSyncDebounced]
  );

  // Update messages with debounced persistence
  // IMPORTANT: Only save messages that are NOT currently streaming to avoid saving partial content
  const updateMessages = useCallback(
    (newMessages: StoredMessage[] | ((prev: StoredMessage[]) => StoredMessage[])) => {
      setMessages((prev) => {
        const updated = typeof newMessages === "function" ? newMessages(prev) : newMessages;
        messagesRef.current = updated;
        
        // Clear any pending save
        if (saveTimeoutRef.current) {
          clearTimeout(saveTimeoutRef.current);
        }
        
        // Check if any message is currently streaming - if so, don't save yet
        const hasStreamingMessage = updated.some((m) => m.isStreaming || m.isTyping);
        
        if (!hasStreamingMessage) {
          // Debounce the save to localStorage only when no message is streaming
          saveTimeoutRef.current = setTimeout(() => {
            // Filter out messages with incomplete content before saving
            const messagesToSave = updated.filter((m) => !m.isStreaming && !m.isTyping);
            saveMessagesToStorage(messagesToSave, activeSessionId);
          }, 300);
        }
        
        return updated;
      });
    },
    [activeSessionId, saveMessagesToStorage]
  );

  // Cleanup save timeout on unmount
  useEffect(() => {
    return () => {
      if (saveTimeoutRef.current) {
        clearTimeout(saveTimeoutRef.current);
      }
    };
  }, []);

  // Switch to a different session
  const selectSession = useCallback((sessionId: string) => {
    try {
      const messagesRaw = localStorage.getItem(SESSION_PREFIX + sessionId);
      if (messagesRaw) {
        const parsed = JSON.parse(messagesRaw);
        setMessages(Array.isArray(parsed) ? parsed : [getDefaultWelcomeMessage(translations)]);
      } else {
        setMessages([getDefaultWelcomeMessage(translations)]);
      }
      setActiveSessionId(sessionId);
    } catch (e) {
      console.error("Error loading session:", e);
      setMessages([getDefaultWelcomeMessage(translations)]);
    }
  }, [translations]);

  // Create a new session
  const createNewSession = useCallback(() => {
    const newSession: ChatSession = {
      id: generateId(),
      title: translations.newConversation,
      createdAt: Date.now(),
      updatedAt: Date.now(),
      preview: translations.startConversation,
    };

    const defaultMessages = [getDefaultWelcomeMessage(translations)];

    try {
      // Save new session
      localStorage.setItem(SESSION_PREFIX + newSession.id, JSON.stringify(defaultMessages));

      setSessions((prev) => {
        const updated = [newSession, ...prev];
        localStorage.setItem(SESSIONS_INDEX_KEY, JSON.stringify(updated));
        return updated;
      });

      setActiveSessionId(newSession.id);
      setMessages(defaultMessages);

      // Sync new session to database
      if (user) {
        syncToDatabase(newSession.id, defaultMessages, newSession);
      }
    } catch (e) {
      console.error("Error creating new session:", e);
    }

    return newSession.id;
  }, [user, syncToDatabase]);

  // Delete a session - atomic operation with safe state transitions
  const deleteSession = useCallback(
    (sessionId: string) => {
      try {
        // Get current sessions from ref to avoid stale state
        const currentSessions = sessionsRef.current;
        
        // Filter out the session to delete
        const remaining = currentSessions.filter((s) => s.id !== sessionId);
        
        // If we're deleting the active session, switch FIRST before any state changes
        if (sessionId === activeSessionId) {
          if (remaining.length > 0) {
            // Find the most recent session to switch to
            const mostRecent = [...remaining].sort((a, b) => b.updatedAt - a.updatedAt)[0];
            
            // Load new session messages BEFORE any React state updates
            let nextMessages: StoredMessage[] = [getDefaultWelcomeMessage()];
            const messagesRaw = localStorage.getItem(SESSION_PREFIX + mostRecent.id);
            if (messagesRaw) {
              try {
                const parsed = JSON.parse(messagesRaw);
                if (Array.isArray(parsed)) {
                  nextMessages = parsed;
                }
              } catch {
                // Keep default messages
              }
            }
            
            // Update refs first to prevent stale reads during React updates
            sessionsRef.current = remaining;
            messagesRef.current = nextMessages;
            
            // Remove deleted session from localStorage
            localStorage.removeItem(SESSION_PREFIX + sessionId);
            localStorage.setItem(SESSIONS_INDEX_KEY, JSON.stringify(remaining));
            
            // Delete from database (async, don't wait)
            if (user) {
              deleteFromDatabase(sessionId);
            }
            
            // Batch all React state updates together
            setMessages(nextMessages);
            setActiveSessionId(mostRecent.id);
            setSessions(remaining);
          } else {
            // Create a new session if all are deleted
            const newSession: ChatSession = {
              id: generateId(),
              title: `âœˆï¸ ${translations.newConversation}`,
              createdAt: Date.now(),
              updatedAt: Date.now(),
              preview: translations.startConversation,
            };
            const defaultMessages = [getDefaultWelcomeMessage(translations)];

            // Update refs first
            sessionsRef.current = [newSession];
            messagesRef.current = defaultMessages;
            
            // Remove deleted session and save new session to localStorage
            localStorage.removeItem(SESSION_PREFIX + sessionId);
            localStorage.setItem(SESSION_PREFIX + newSession.id, JSON.stringify(defaultMessages));
            localStorage.setItem(SESSIONS_INDEX_KEY, JSON.stringify([newSession]));
            
            // Delete from database
            if (user) {
              deleteFromDatabase(sessionId);
            }

            // Batch React state updates
            setMessages(defaultMessages);
            setActiveSessionId(newSession.id);
            setSessions([newSession]);
          }
        } else {
          // Not deleting active session - simpler case
          sessionsRef.current = remaining;
          
          localStorage.removeItem(SESSION_PREFIX + sessionId);
          localStorage.setItem(SESSIONS_INDEX_KEY, JSON.stringify(remaining));
          
          if (user) {
            deleteFromDatabase(sessionId);
          }
          
          setSessions(remaining);
        }
      } catch (e) {
        console.error("Error deleting session:", e);
      }
    },
    [activeSessionId, user, deleteFromDatabase]
  );

  // Delete ALL sessions (clear history completely)
  const deleteAllSessions = useCallback(() => {
    try {
      // Cancel any pending saves/syncs that could re-create data right after clearing
      if (saveTimeoutRef.current) {
        clearTimeout(saveTimeoutRef.current);
        saveTimeoutRef.current = null;
      }
      if (syncTimeoutRef.current) {
        clearTimeout(syncTimeoutRef.current);
        syncTimeoutRef.current = null;
      }
      isSyncingRef.current = false;

      // Prevent state/storage churn while we are nuking everything
      isUpdatingRef.current = true;

      // Get all session IDs to delete from database
      const sessionIds = sessionsRef.current.map((s) => s.id);

      // Clear localStorage for chat sessions
      sessionIds.forEach((id) => {
        localStorage.removeItem(SESSION_PREFIX + id);
      });
      localStorage.removeItem(SESSIONS_INDEX_KEY);

      // Also clear any flight/accommodation/travel memory keys
      localStorage.removeItem("travliaq_flight_memory");
      localStorage.removeItem("travliaq_accommodation_memory");
      localStorage.removeItem("travliaq_travel_memory");
      localStorage.removeItem("travliaq_preferences");

      // Create fresh session
      const newSession: ChatSession = {
        id: generateId(),
        title: "âœˆï¸ Nouvelle conversation",
        createdAt: Date.now(),
        updatedAt: Date.now(),
        preview: "DÃ©marrez la conversation...",
      };
      const defaultMessages = [getDefaultWelcomeMessage()];

      // Save new session
      localStorage.setItem(SESSION_PREFIX + newSession.id, JSON.stringify(defaultMessages));
      localStorage.setItem(SESSIONS_INDEX_KEY, JSON.stringify([newSession]));

      // Update refs
      sessionsRef.current = [newSession];
      messagesRef.current = defaultMessages;

      // Update state (batched by React)
      setSessions([newSession]);
      setActiveSessionId(newSession.id);
      setMessages(defaultMessages);

      // Delete from database (async)
      if (user) {
        sessionIds.forEach((id) => deleteFromDatabase(id));
      }

      console.log("[ChatSessions] Deleted all sessions");
    } catch (e) {
      console.error("Error deleting all sessions:", e);
    } finally {
      isUpdatingRef.current = false;
    }
  }, [user, deleteFromDatabase]);

  // Force sync current session to database (for critical actions)
  const forceSyncToDatabase = useCallback(() => {
    if (!user || !activeSessionId) return;
    
    if (syncTimeoutRef.current) {
      clearTimeout(syncTimeoutRef.current);
    }
    
    const currentSession = sessions.find(s => s.id === activeSessionId);
    syncToDatabase(activeSessionId, messages, currentSession);
  }, [user, activeSessionId, messages, sessions, syncToDatabase]);

  // Get current session metadata
  const getSessionMetadata = useCallback(() => {
    const currentSession = sessions.find(s => s.id === activeSessionId);
    return {
      title: currentSession?.title || "Nouvelle conversation",
      preview: currentSession?.preview || "DÃ©marrez la conversation...",
    };
  }, [sessions, activeSessionId]);

  return {
    sessions,
    activeSessionId,
    messages,
    updateMessages,
    selectSession,
    createNewSession,
    deleteSession,
    deleteAllSessions,
    forceSyncToDatabase,
    getSessionMetadata,
  };
};
