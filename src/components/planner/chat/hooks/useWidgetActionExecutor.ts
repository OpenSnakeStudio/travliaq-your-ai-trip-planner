/**
 * useWidgetActionExecutor - Execute LLM-chosen widget actions
 * 
 * This hook handles the "chooseWidget" action from the LLM,
 * allowing the AI to make intelligent choices on behalf of the user.
 */

import { useCallback } from "react";
import type { WidgetType } from "@/types/flight";
import type { ChatMessage } from "../types";
import type { DestinationSuggestion } from "@/types/destinations";

export interface ChooseWidgetAction {
  type: "chooseWidget";
  widgetType: WidgetType;
  option: string;
  optionData?: Record<string, unknown>;
  reason?: string;
}

export interface WidgetActionExecutorOptions {
  messages: ChatMessage[];
  setMessages: React.Dispatch<React.SetStateAction<ChatMessage[]>>;
  
  // Widget handlers from useChatWidgetFlow
  handleCitySelect: (messageId: string, cityName: string, countryName: string, countryCode: string) => void;
  handleTripTypeConfirm: (messageId: string, tripType: "roundtrip" | "oneway" | "multi") => void;
  handleTravelersSelect: (messageId: string, travelers: { adults: number; children: number; infants: number }) => void;
  handleDateSelect: (messageId: string, type: "departure" | "return", date: Date) => void;
  handleDateRangeSelect: (messageId: string, departure: Date, returnDate: Date) => void;
  
  // Inspire flow handlers
  onDestinationSelect?: (destination: DestinationSuggestion) => void;
  onStyleContinue?: () => void;
  onInterestsContinue?: () => void;
}

export function useWidgetActionExecutor(options: WidgetActionExecutorOptions) {
  const { 
    messages, 
    setMessages,
    handleCitySelect,
    handleTripTypeConfirm,
    handleTravelersSelect,
    handleDateSelect,
    handleDateRangeSelect,
    onDestinationSelect,
    onStyleContinue,
    onInterestsContinue,
  } = options;

  /**
   * Find the message containing the pending widget of a specific type
   */
  const findWidgetMessage = useCallback((widgetType: WidgetType): ChatMessage | undefined => {
    // Search from most recent to oldest
    for (let i = messages.length - 1; i >= 0; i--) {
      const m = messages[i];
      if (m.widget === widgetType && !m.widgetConfirmed) {
        return m;
      }
    }
    return undefined;
  }, [messages]);

  /**
   * Add an auto-generated user message explaining the LLM choice
   */
  const addAutoGeneratedMessage = useCallback((text: string) => {
    const autoMessage: ChatMessage = {
      id: `auto-user-${Date.now()}`,
      role: "user",
      text,
      isAutoGenerated: true,
    };
    setMessages((prev) => [...prev, autoMessage]);
  }, [setMessages]);

  /**
   * Execute a chooseWidget action from the LLM
   */
  const executeChooseWidgetAction = useCallback((action: ChooseWidgetAction): boolean => {
    const { widgetType, option, optionData, reason } = action;
    
    console.log("[WidgetActionExecutor] Executing chooseWidget:", { widgetType, option, reason });

    // Find the message with this widget
    const widgetMessage = findWidgetMessage(widgetType);
    
    if (!widgetMessage) {
      console.warn("[WidgetActionExecutor] No pending widget found for type:", widgetType);
      return false;
    }

    const messageId = widgetMessage.id;

    switch (widgetType) {
      // Destination suggestions (Inspire flow)
      case "destinationSuggestions": {
        if (onDestinationSelect && widgetMessage.widgetData?.suggestions) {
          const suggestions = widgetMessage.widgetData.suggestions as DestinationSuggestion[];
          // Find the matching destination by countryName or headline
          const destination = suggestions.find(
            (d) => d.countryName.toLowerCase() === option.toLowerCase() ||
                   d.headline?.toLowerCase().includes(option.toLowerCase())
          );
          
          if (destination) {
            // Add auto-generated message
            addAutoGeneratedMessage(
              `Je choisis **${destination.countryName}** ${reason ? `(${reason})` : ""}`
            );
            onDestinationSelect(destination);
            return true;
          } else {
            console.warn("[WidgetActionExecutor] Destination not found in suggestions:", option);
            return false;
          }
        }
        return false;
      }

      // City selector
      case "citySelector": {
        const cityData = widgetMessage.widgetData?.citySelection as { 
          countryCode: string; 
          countryName: string;
          cities?: Array<{ name: string }>;
        } | undefined;
        
        if (cityData) {
          // Verify the city exists in options
          const cities = cityData.cities || [];
          const matchedCity = cities.find((c) => c.name.toLowerCase() === option.toLowerCase());
          
          if (matchedCity || cities.length === 0) {
            // Add auto-generated message
            addAutoGeneratedMessage(
              `Je choisis **${option}** ${reason ? `(${reason})` : ""}`
            );
            handleCitySelect(messageId, option, cityData.countryName, cityData.countryCode);
            return true;
          }
        }
        return false;
      }

      // Trip type confirmation
      case "tripTypeConfirm": {
        const tripType = option.toLowerCase() as "roundtrip" | "oneway" | "multi";
        const validTypes: Record<string, "roundtrip" | "oneway" | "multi"> = {
          "roundtrip": "roundtrip",
          "aller-retour": "roundtrip",
          "oneway": "oneway",
          "aller simple": "oneway",
          "multi": "multi",
          "multi-destinations": "multi",
        };
        
        const normalizedType = validTypes[tripType];
        if (normalizedType) {
          const labels = { roundtrip: "Aller-retour", oneway: "Aller simple", multi: "Multi-destinations" };
          addAutoGeneratedMessage(
            `Je choisis **${labels[normalizedType]}** ${reason ? `(${reason})` : ""}`
          );
          handleTripTypeConfirm(messageId, normalizedType);
          return true;
        }
        return false;
      }

      // Travelers selector
      case "travelersSelector": {
        // Parse "2 adultes, 1 enfant" format or use optionData
        if (optionData && typeof optionData.adults === "number") {
          addAutoGeneratedMessage(
            `Je configure **${optionData.adults} adulte(s)${optionData.children ? `, ${optionData.children} enfant(s)` : ""}** ${reason ? `(${reason})` : ""}`
          );
          handleTravelersSelect(messageId, {
            adults: optionData.adults as number,
            children: (optionData.children as number) || 0,
            infants: (optionData.infants as number) || 0,
          });
          return true;
        }
        
        // Parse text format
        const adults = parseInt(option.match(/(\d+)\s*adulte/i)?.[1] || "1");
        const children = parseInt(option.match(/(\d+)\s*enfant/i)?.[1] || "0");
        const infants = parseInt(option.match(/(\d+)\s*bébé/i)?.[1] || "0");
        
        addAutoGeneratedMessage(
          `Je configure **${adults} adulte(s)${children ? `, ${children} enfant(s)` : ""}** ${reason ? `(${reason})` : ""}`
        );
        handleTravelersSelect(messageId, { adults, children, infants });
        return true;
      }

      // Date picker
      case "datePicker": {
        const date = new Date(option);
        if (!isNaN(date.getTime())) {
          addAutoGeneratedMessage(
            `Je choisis le **${date.toLocaleDateString("fr-FR", { day: "numeric", month: "long", year: "numeric" })}** ${reason ? `(${reason})` : ""}`
          );
          handleDateSelect(messageId, "departure", date);
          return true;
        }
        return false;
      }

      // Return date picker
      case "returnDatePicker": {
        const date = new Date(option);
        if (!isNaN(date.getTime())) {
          addAutoGeneratedMessage(
            `Je choisis le retour le **${date.toLocaleDateString("fr-FR", { day: "numeric", month: "long", year: "numeric" })}** ${reason ? `(${reason})` : ""}`
          );
          handleDateSelect(messageId, "return", date);
          return true;
        }
        return false;
      }

      // Date range picker
      case "dateRangePicker": {
        if (optionData && optionData.departure && optionData.return) {
          const departure = new Date(optionData.departure as string);
          const returnDate = new Date(optionData.return as string);
          if (!isNaN(departure.getTime()) && !isNaN(returnDate.getTime())) {
            addAutoGeneratedMessage(
              `Je configure les dates: **${departure.toLocaleDateString("fr-FR")} → ${returnDate.toLocaleDateString("fr-FR")}** ${reason ? `(${reason})` : ""}`
            );
            handleDateRangeSelect(messageId, departure, returnDate);
            return true;
          }
        }
        return false;
      }

      // Preference style (Inspire flow)
      case "preferenceStyle": {
        if (onStyleContinue) {
          addAutoGeneratedMessage(
            `Je valide le style de voyage ${reason ? `(${reason})` : ""}`
          );
          onStyleContinue();
          return true;
        }
        return false;
      }

      // Preference interests (Inspire flow)
      case "preferenceInterests": {
        if (onInterestsContinue) {
          addAutoGeneratedMessage(
            `Je valide les centres d'intérêt ${reason ? `(${reason})` : ""}`
          );
          onInterestsContinue();
          return true;
        }
        return false;
      }

      default:
        console.warn("[WidgetActionExecutor] Unhandled widget type:", widgetType);
        return false;
    }
  }, [
    findWidgetMessage,
    addAutoGeneratedMessage,
    handleCitySelect,
    handleTripTypeConfirm,
    handleTravelersSelect,
    handleDateSelect,
    handleDateRangeSelect,
    onDestinationSelect,
    onStyleContinue,
    onInterestsContinue,
  ]);

  /**
   * Check if a "choose for me" request can be handled
   */
  const canChooseForUser = useCallback((widgetType?: WidgetType): boolean => {
    if (widgetType) {
      return !!findWidgetMessage(widgetType);
    }
    // Check if any widget is pending
    return messages.some((m) => m.widget && !m.widgetConfirmed);
  }, [messages, findWidgetMessage]);

  /**
   * Get pending widgets for context
   */
  const getPendingWidgets = useCallback((): Array<{ type: WidgetType; messageId: string; options?: string[] }> => {
    return messages
      .filter((m) => m.widget && !m.widgetConfirmed)
      .map((m) => {
        let options: string[] | undefined;
        
        // Extract options based on widget type
        if (m.widget === "destinationSuggestions" && m.widgetData?.suggestions) {
          options = (m.widgetData.suggestions as DestinationSuggestion[]).map((d) => d.countryName);
        } else if (m.widget === "citySelector" && m.widgetData?.citySelection?.cities) {
          options = (m.widgetData.citySelection.cities as Array<{ name: string }>).map((c) => c.name);
        } else if (m.widget === "tripTypeConfirm") {
          options = ["Aller-retour", "Aller simple", "Multi-destinations"];
        }
        
        return {
          type: m.widget!,
          messageId: m.id,
          options,
        };
      });
  }, [messages]);

  return {
    executeChooseWidgetAction,
    findWidgetMessage,
    canChooseForUser,
    getPendingWidgets,
  };
}
